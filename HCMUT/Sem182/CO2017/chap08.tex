%!TEX root = main.tex

\chapter{Main Memory}

\hi{Background}
  \hii{Basic Hardware}
    \par CPU can only directly access main memory and registers. If data are not in memory, they must be moved there before the CPU can operate on them.
    \par CPU can decode instructions and perform operations on register contents at the rate of 1 or more operations per clock tick. Meanwhile, a memory access may take many cycles and the processor would need to \tb{stall} before it gets the data required for execution. One solution is to use cache.
    \par Each process has a \ti{separate memory space}. The range of legal addresses that the process may access is determined by two registers:
    \begin{itemize}
      \item base register: holds the smallest legal physical memory address
      \item limit register: specifies the size of the range of memory space
    \end{itemize}
    \par Example: base register is 300000, limit register is 123460, then program can legally access addresses from 300000 to 423459 (inclusive).
    \par Protection of memory space is done by the CPU hardware compare every address generated in user mode with the register. Any illegal access results in a fatal error.
    \par Base and limit registers can be loaded only by the OS with a special privileged. Privileged instructions can be executed only in kernel mode, and only the OS executes in kernel mode, therefore only the operating system can load the base and limit registers.
    \par The OS is given unrestricted access to the OS memory and users' memory.

  \hii{Address Binding}
    \par A \ti{program} resides on disk as a binary executable file. To be executed, the program must be brought into memory and placed within a \ti{process}.
    \par Depending on the memory management in use, the process may be moved between disk and memory during its execution. The processes on the disk that are waiting to be brought into memory for execution form the \tb{input queue}.
    \par In most systems, a user process can reside in any part of the physical memory. (For example, the address space of a computer starts at 00000, but the first address of a user process need not be 00000).
    \par A user program goes through several steps before being executed. During these steps, addresses may be represented in different ways:
    \begin{itemize}
      \item Addresses in the source program are generally symbolic address (symbolic addresses are addresses with name used in Assembly language).
      \item The compiler will bind the symbolic addresses to relocatable addresses (changing names to number; for example, changing the name \texttt{count} to \texttt{14}).
      \item The linkage editor or loader will bind the relocatable addresses to absolute addresses (74014, for example).
    \end{itemize}
    \par Each \tb{binding} is a \ti{mapping} from one address space to another.
    \par The binding of instructions and data to memory addresses can be done at any of these steps:
    \begin{itemize}
      \item \tb{Compile time}: if at compile time the location of the process in the memory is known, then \tb{absolute code} can be generated.
      \item \tb{Load time}: if at compile time the location of the process is not known, then the compiler must generate \tb{relocatable code}. Binding is delayed until load time.
      \item \tb{Execution time}:  if the process can be moved during its execution from one memory segment to another, then binding must be delayed until run time.
    \end{itemize}

  \hii{Logical vs Physical Address Space}
    \par A \tb{logical address} is an address generated by the CPU.
    \par A \tb{physcial address} is the address seen by the memory unit, or the address loaded into the \tb{memory-address register} of the memory.
    \par Compile-time and load-time address-binding methods generate identical logical and physical addresses. However, execution-time address-binding results in different logical and physical addresses. In this case, we refer to the logical address as a \tb{virtual address}. \ti{These two terms are used interchangeably in the book}.
    \par The set of all logical addresses generated by a program is a \tb{logical address space}; the set of all physical addresses corresponding to these logical addresses is a \tb{physical address space}. Thus, in the execution-time address-binding scheme, the logical and physical address spaces differ.
    \par The run-time mapping from logical to physical addresses is done by a hardware device called the \tb{memory-management unit} (MMU). The user program never sees the \ti{physical addresses} - it only operates on \ti{virtual/logical addresses}.
    \par Example: a program may create a pointer at logical address 123. However, in the physical memory the real physical location is 10123, as the starting address of the process is 10000.